原型 -> 装配 -> 成型 -> 模组

# 原型

原型提供一件装备的基本模型，类型框架，perk与内部升级材料。

内部升级的总次数为perk列数+固有词条列数，可以强化原型装备的词条。

# 装配

根据装备类型，一件装备由不同的部件组成。不同部件可以通过不同材料制作。

部件的基础形态可以通过对应的生产方式由材料产出。在基础部件被安装至装备的过程中，可以修改器子类型。

子类型会指定一系列`加工方法`，与装配台链接的机器可以提供对应的`加工方法`。
当所有`加工方法`条件均被满足时，即可对该种子部件进行对应改造。

机器提供的`加工方法`也有等级限制，需要高于材料强度等级才能处理。


# 枪械

## 弹药

枪械的类型与框架决定了一把枪械可以使用哪些弹药，由tag提供。

一般来说，某一武器可用的弹药种类是其框架可用类与类型可用类的并集。

特定的装备也可以通过覆写方法来决定可用的弹药。

弹药提供一个伤害倍率，一个伤害结构修改器，以及可选的额外命中效果。

```java
import java.util.Set;

public interface IAmmoConsumable extends IDamageContentProvider {
    Set<AmmoType> allowedAmmoTypes();

    default AmmoData getAmmoLoading(ItemStack stack) {
        return stack.component(AMMO_COMPONENT);
    }

    @Override
    default DamageContent getDamageContent(ItemStack stack) {
        //apply damage factor and content modifier
    }
}

public class AmmoType {
    public final float damageFactor;
    public final DamageContentModifier contentModifier;

    public AmmoType(float damageFactor, DamageContentModifier modifier) {
        this.damageFactor = damageFactor;
        this.contentModifier = modifier;
    }

    public AmmoType(float damageFactor) {
        this(damageFactor, DamageContentModifier.NONE);
    }

    public AmmoType(DamageContentModifier modifier) {
        this(1, modifier);
    }
    
    public void onHitBlock(Level level, BlockPos pos, LivingEntity shooter, ItemStack weapon){
        //shooter and weapon is nonnull by default but nullable.
    }
    
    public void onHitEntity(Entity entity){
    }
}
```

# 关于数值

mod应当读取一个.jsonl文件，该文件每行对应一个材料

每行的json对象形如：

```json
{
  "材料id" : 1,
  "部件1" : {
    "数值1" : 114,
    "数值2" : 514
  },
  "部件2" : {
    "数值1" : 1919,
    "数值2" : 810
  }
}
```
该jsonl通过一个程序生成
`我会自己写这个——Crashes`

mod找不到组件材料数值时应当提供一个错误信息且将数字设为异常的值